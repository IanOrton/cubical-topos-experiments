----------------------------------------------------------------------
-- This Agda code is designed to accompany the paper "Axioms for
-- Modelling Cubical Type Theory in a Topos" (CSL Special Issue
-- version). 
--
-- The idea for getting an impredicative universe of propositions ฮฉ
-- comes from Martin Escardo, more details can be found at:
--
--          http://www.cs.bham.ac.uk/~mhe/impredicativity/          
----------------------------------------------------------------------

{-# OPTIONS --rewriting #-}
module replace where 

open import Agda.Builtin.TrustMe
open import prelude
open import impredicative
open import interval
open import cof
open import fibrations


----------------------------------------------------------------------
-- Lemmas about subst
----------------------------------------------------------------------
substcancel :
  {โ โ' : Level}
  {A : Set โ}
  (B : A โ Set โ')
  {x y : A}
  (f : (a : A) โ B a)
  (p : x โก y)
  {z : A}
  (q : x โก z)
  (r : y โก z)
  โ ------------------------
  subst B q (f x) โก subst B r (f y)
substcancel _ _ refl refl refl = refl

substtrans :
  {โ โ' : Level}
  {A : Set โ}
  (B : A โ Set โ')
  {x y z : A}
  (p : x โก y)
  (q : y โก z)
  (r : x โก z)
  (b : B x)
  โ ------------------------
  subst B q (subst B p b)  โก subst B r b
substtrans _ refl refl refl _ = refl

substcong :
  {โ โ' : Level}
  {A A' : Set โ}
  (B : A' โ Set โ')
  (f : A โ A')
  {x y : A}
  (p : x โก y)
  (b : B (f x))
  โ ------------------------
  subst (B โ f) p b โก subst B (cong f p) b
substcong _ _ refl _ = refl

----------------------------------------------------------------------
-- Quoitents
----------------------------------------------------------------------
infix 6 _/_ [_]/_
postulate
  -- quotient formation
  _/_ : {โ โ' : Level}(A : Set โ)(R : A โ A โ Set โ') โ Set (โ โ โ')
  
  -- quotient introduction
  [_]/_ : {โ โ' : Level}{A : Set โ} โ A โ (R : A โ A โ Set โ') โ A / R

  -- generating equalities
  qeq :
    {โ โ' : Level}
    {A : Set โ}
    {x y : A}
    (R : A โ A โ Set โ')
    (r : R x y)
    โ ------------------
    [ x ]/ R โก [ y ]/ R

  -- quotient induction
  qind :
    {โ โ' โ'' : Level}
    {A : Set โ}
    (R : A โ A โ Set โ')
    (B : A / R โ Set โ'')
    (f : (x : A) โ B ([ x ]/ R))
    (e : (x y : A)(r : R x y) โ subst B (qeq R r) (f x) โก f y)
    โ --------------------------------------------------------
    (y : A / R) โ B y

  -- quotient computation
  qind-comp :
    {โ โ' โ'' : Level}
    {A : Set โ}
    (R : A โ A โ Set โ')
    (B : A / R โ Set โ'')
    (f : (x : A) โ B ([ x ]/ R))
    (e : (x y : A)(r : R x y) โ subst B (qeq R r) (f x) โก f y)
    (x : A)
    โ --------------------------------------------------------
    qind R B f e ([ x ]/ R) โก f x

{-# REWRITE qind-comp   #-}

-- N.B. Not sure if these are correct:
{-# POLARITY _/_ * * ++ ++ #-}
{-# POLARITY [_]/_ * * _ * _ #-}

----------------------------------------------------------------------
-- Fibrant replacement of an object
----------------------------------------------------------------------
isFibObj : Set โ Set
isFibObj A = isFib {ฮ = Unit} (ฮป _ โ A)

mutual
  -- FreeComps A is the result of freely adding compositions to A
  data FreeComps (A : Set) : Set where
    pure : A โ FreeComps A
    comp :
      (e : OI)
      (ฯ : Cof)
      (f : [ ฯ ] โ Int โ Replace A)
      (aโ : โฆ aโ โ Replace A โฃ (ฯ , f) โ โจ e โฉ โ aโ โง)
      โ FreeComps A

  -- Replace A is FreeComps A where we quotient by the equation:
  --     comp e cofTrue f aโ = f tt
  -- i.e. we ensure that compositions always extend their partial input
  Replace : Set โ Set
  Replace A = FreeComps A / TotalComps

  -- TotalComps is the inductive family describing the necessary relation
  data TotalComps {A : Set} : FreeComps A โ FreeComps A โ Set where
    total :
      (e : OI)
      (ฯ : Cof)
      (f : [ ฯ ] โ Int โ Replace A)
      (aโ : โฆ aโ โ Replace A โฃ (ฯ , f) โ โจ e โฉ โ aโ โง)
      (u : [ ฯ ])
      (a : FreeComps A)
      (_ : [ a ]/ TotalComps โก f u โจ ! e โฉ)
      โ TotalComps a (comp e ฯ f aโ)

-- The inclusion of A in Replace A
ฮน : {A : Set} โ A โ Replace A
ฮน a = [ pure a ]/ TotalComps

-- Replace A is always a fibrant object
replaceIsFib : (A : Set) โ isFibObj (Replace A)
replaceIsFib A e p ฯ f aโ = [ comp e ฯ f aโ ]/ TotalComps , ext where
  ext : (u : [ ฯ ]) โ f u โจ ! e โฉ โก [ comp e ฯ f aโ ]/ TotalComps
  ext u = qind TotalComps
    (ฮป a โ (_ : a โก f u โจ ! e โฉ) โ a โก [ comp e ฯ f aโ ]/ TotalComps)
    (ฮป a p โ qeq TotalComps (total e ฯ f aโ u a p))
    (ฮป _ _ _ โ funext (ฮป _ โ uip _ _))
    (f u โจ ! e โฉ) refl

-- We get a principle for eliminating into fibrant objects
replaceElim :
  (A : Set)
  (B : Set)(ฮฒ : isFibObj B)
  (f : A โ B)
  โ --------------------
  Replace A โ B

-- We need to mark this as terminating, but this should (hopefully) be ok
{-# TERMINATING #-}
replaceElim A B ฮฒ f = elim where
  elim : Replace A โ B
  f' : (x : FreeComps A) โ B
  resp : (x y : FreeComps A) (r : TotalComps x y) โ subst (ฮป _ โ B) (qeq TotalComps r) (f' x) โก f' y
  elim = qind TotalComps (ฮป _ โ B) f' resp
  f' (pure x) = f x
  f' (comp e ฯ g (aโ , ext)) = fst (ฮฒ e (ฮป _ โ tt) ฯ (ฮป u i โ elim (g u i))
    (elim aโ , ฮป u โ cong (qind TotalComps (ฮป _ โ B) f' resp) (ext u)))
  resp a .(comp e ฯ g (aโ , ext)) (total e ฯ g (aโ , ext) u .a eq) =
    proof:
      subst (ฮป _ โ B) (qeq TotalComps (total e ฯ g (aโ , ext) u a eq)) (f' a)
        โก[ substconst _ (qeq TotalComps (total e ฯ g (aโ , ext) u a eq)) (f' a) ]โก
      f' a
        โก[ cong elim eq ]โก
      elim (g u โจ ! e โฉ)
        โก[ snd (ฮฒ e (ฮป _ โ tt) ฯ (ฮป u i โ elim (g u i))
             (elim aโ , ฮป u โ cong (qind TotalComps (ฮป _ โ B) f' resp) (ext u))) u ]โก
      fst (ฮฒ e (ฮป _ โ tt) ฯ (ฮป u i โ elim (g u i))
        (elim aโ , ฮป u โ cong (qind TotalComps (ฮป _ โ B) f' resp) (ext u)))
        โก[ refl ]โก
      f' (comp e ฯ g (aโ , ext))
    qed

-- Every f : A --> B factors as (replaceElim f) โ ฮน
--
--  A --------> B
--   \         โ
--    \       /
--     \    /
--      โ /
--   Replace A
--
replaceElimFactors :
  (A : Set)
  (B : Set)(ฮฒ : isFibObj B)
  (f : A โ B)
  โ ---------------
  (replaceElim A B ฮฒ f) โ ฮน โก f
replaceElimFactors A B ฮฒ f = refl 


-- A corresponding induction principle
replaceInd :
  (A : Set)
  (B : Replace A โ Set)(ฮฒ : isFib B)
  (f : (a : A) โ B (ฮน a))
  โ --------------------
  (x : Replace A) โ B x
{-# TERMINATING #-}
replaceInd A B ฮฒ f = elim where
  elim : (x : Replace A) โ B x
  f' : (x : FreeComps A) โ B ([ x ]/ TotalComps)
  resp : (x y : FreeComps A) (r : TotalComps x y) โ subst B (qeq TotalComps r) (f' x) โก f' y
  elim = qind TotalComps B f' resp
  f' (pure x) = f x
  f' (comp e ฯ g (aโ , ext)) =
    let p = fill e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext in
    let g' u i = subst B (appCong (fst (snd p) u)) (elim (g u i)) in
    let aโ' = subst B (symm (snd (snd p))) (elim aโ) in
    let ext' u = substcancel B elim (ext u) (appCong (fst (snd p) u)) (symm (snd (snd p))) in
    let aโ' = fst (ฮฒ e (fst p) ฯ g' (aโ' , ext')) in
    subst B (fillAtEnd e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext) aโ'
  resp a .(comp e ฯ g (aโ , ext)) (total e ฯ g (aโ , ext) u .a eq) =
    let p = fill e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext in
    let g' u i = subst B (appCong (fst (snd p) u)) (elim (g u i)) in
    let aโ' = subst B (symm (snd (snd p))) (elim aโ) in
    let ext' u = substcancel B elim (ext u) (appCong (fst (snd p) u)) (symm (snd (snd p))) in
    let aโ' = fst (ฮฒ e (fst p) ฯ g' (aโ' , ext')) in
    proof:

      subst B (qeq TotalComps (total e ฯ g (aโ , ext) u a eq)) (f' a)

          โก[ substcancel B elim eq
               (qeq TotalComps (total e ฯ g (aโ , ext) u a eq))
               (snd (replaceIsFib A e (ฮป _ โ tt) ฯ g (aโ , ext)) u) ]โก

      subst B (snd (replaceIsFib A e (ฮป _ โ tt) ฯ g (aโ , ext)) u) (elim (g u โจ ! e โฉ))

          โก[ symm (substtrans B
                    (appCong (fst (snd p) u))
                    (fillAtEnd e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext)
                    (snd (replaceIsFib A e (ฮป _ โ tt) ฯ g (aโ , ext)) u)
                    (elim (g u โจ ! e โฉ))) ]โก

      subst B (fillAtEnd e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext) (g' u โจ ! e โฉ)
   
          โก[ cong (subst B (fillAtEnd e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext))
                  (snd (ฮฒ e (fst p) ฯ g' (aโ' , ext')) u) ]โก

      subst B (fillAtEnd e (replaceIsFib A) (ฮป _ โ tt) ฯ g aโ ext) aโ'

          โก[ refl ]โก

      f' (comp e ฯ g (aโ , ext))

    qed


-- And a corresponding factorisation lemma
replaceIndFactors : (A : Set)(B : Replace A โ Set)(ฮฒ : isFib B)(f : (a : A) โ B (ฮน a))
  โ (ฮป a โ replaceInd A B ฮฒ f (ฮน a)) โก f
replaceIndFactors A B ฮฒ f = refl 

----------------------
-- ๐ยน
----------------------
open import Data.paths

data Endpoints : Int โ Int โ Set where
  I=O : Endpoints I O

pre๐ยน : Set
pre๐ยน = Int / Endpoints

๐ยน : Set
๐ยน = Replace pre๐ยน

๐ยนfib : isFibObj ๐ยน
๐ยนfib = replaceIsFib pre๐ยน

base : ๐ยน
base = ฮน ([ O ]/ Endpoints)

loop : base ~ base
loop = p , refl , cong ฮน (qeq Endpoints I=O) where
  p : Int โ ๐ยน
  p i = ฮน ([ i ]/ Endpoints)

๐ยน-elim :
  (P : ๐ยน โ Set)
  (ฯ : isFib P)
  (a : P base)
  (l : (i : Int) โ P (loop at i))
  (lO : subst P (atO loop) (l O) โก a)
  (lI : subst P (atI loop) (l I) โก a)
  โ ---------------------
  (x : ๐ยน) โ P x
๐ยน-elim P ฯ a l lO lI x = replaceInd pre๐ยน P ฯ f x where
  f : (x : pre๐ยน) โ P (ฮน x)
  f = qind Endpoints (P โ ฮน) l resp where
    resp : (i j : Int) (r : Endpoints i j) โ
      subst (P โ ฮน) (qeq Endpoints r) (l i) โก l j
    resp .I .O I=O =
      proof:
        subst (P โ ฮน) (qeq Endpoints I=O) (l I)
          โก[ substcong P ฮน (qeq Endpoints I=O) (l I) ]โก
        subst P (cong ฮน (qeq Endpoints I=O)) (l I)
          โก[ lI ]โก
        a
          โก[ symm lO ]โก
        l O
      qed

-----------------------------
-- Suspension (of an object)
-----------------------------
data preSusp (X : Set) : Set where
  preNorth : preSusp X
  preSouth : preSusp X
  preMerid : X โ Int โ preSusp X

data MeridEnds {X : Set} : preSusp X โ preSusp X โ Set where
  meridO : (x : X) โ MeridEnds (preMerid x O) preNorth
  meridI : (x : X) โ MeridEnds (preMerid x I) preSouth

Susp : Set โ Set
Susp X = Replace (preSusp X / MeridEnds)

north : {X : Set} โ Susp X
north = ฮน ([ preNorth ]/ MeridEnds)

south : {X : Set} โ Susp X
south = ฮน ([ preSouth ]/ MeridEnds)

merid : {X : Set} โ X โ north ~ south
merid {X} x = p , (cong ฮน (qeq MeridEnds (meridO x))) , cong ฮน (qeq MeridEnds (meridI x)) where
  p : Int โ Susp X
  p i = ฮน ([ preMerid x i ]/ MeridEnds)

Susp-elim :
  (X  : Set)
  (P  : Susp X โ Set)
  (ฯ  : isFib P)
  (an : P north)
  (as : P south)
  (al : (x : X)(i : Int) โ P (merid x at i))
  (lO : (x : X) โ subst P (atO (merid x)) (al x O) โก an)
  (lI : (x : X) โ subst P (atI (merid x)) (al x I) โก as)
  โ ---------------------
  (x : Susp X) โ P x
Susp-elim X P ฯ an as al lO lI = replaceInd _ P ฯ f where
  f : (x : preSusp X / MeridEnds) โ P (ฮน x)
  f = qind MeridEnds (P โ ฮน) f' resp where
    f' : (x : preSusp X) โ (P โ ฮน) ([ x ]/ MeridEnds)
    f' preNorth = an
    f' preSouth = as
    f' (preMerid x i) = al x i
    resp : (x y : preSusp X) (r : MeridEnds x y) โ
      subst (P โ ฮน) (qeq MeridEnds r) (f' x) โก f' y
    resp .(preMerid x O) .preNorth (meridO x) =
      proof:
        subst (P โ ฮน) (qeq MeridEnds (meridO x)) (al x O)
          โก[ substcong P ฮน (qeq MeridEnds (meridO x)) (al x O) ]โก
        subst P (cong ฮน (qeq MeridEnds (meridO x))) (al x O)
          โก[ lO x ]โก
        an
      qed
    resp .(preMerid x I) .preSouth (meridI x) =
      proof:
        subst (P โ ฮน) (qeq MeridEnds (meridI x)) (al x I)
          โก[ substcong P ฮน (qeq MeridEnds (meridI x)) (al x I) ]โก
        subst P (cong ฮน (qeq MeridEnds (meridI x))) (al x I)
          โก[ lI x ]โก
        as
      qed

SuspFunctorial : 
  (X Y : Set)
  (f : X โ Y)
  โ ---------------------
  Susp X โ Susp Y
SuspFunctorial X Y f =
  Susp-elim X (ฮป _ โ Susp Y) (reindex (ฮป _ โ Susp Y) (replaceIsFib (preSusp Y / MeridEnds)) (ฮป _ โ tt))
    north  -- north โฆ north
    south  -- south โฆ south
    (ฮป x i โ (merid (f x)) at i)  -- merid x โฆ merid (f x)
    (ฮป x โ proof:
      subst (ฮป _ โ Susp Y) (atO (merid x)) (merid (f x) at O)
        โก[ substconst (Susp Y) (atO (merid x)) (merid (f x) at O) ]โก
      merid (f x) at O
        โก[ atO (merid (f x)) ]โก
      north
    qed)
    (ฮป x โ proof:
      subst (ฮป _ โ Susp Y) (atI (merid x)) (merid (f x) at I)
        โก[ substconst (Susp Y) (atI (merid x)) (merid (f x) at I) ]โก
      merid (f x) at I
        โก[ atI (merid (f x)) ]โก
      south
    qed)

 
